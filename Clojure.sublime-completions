{
    "scope": "source.clojure",

    "completions":
    [
        // keywords
        ":private", ":doc", ":test", ":tag", ":file", ":line", ":ns", ":macro",
        ":arglists","ArrayChunk","Vec","VecNode","VecSeq","*'","*1","*2","*3",
        "*agent*","*clojure-version*","*command-line-args*","*compile-files*",
        "*compile-path*","*compiler-options*","*data-readers*","*default-data-reader-fn*",
        "*e","*err*","*file*","*flush-on-newline*","*in*","*ns*","*out*","*print-dup*",
        "*print-length*","*print-level*","*print-meta*","*print-readably*",
        "*read-eval*","*unchecked-math*","*warn-on-reflection*","","+'","-'",
        "->","->>","->ArrayChunk","->Vec","->VecNode","->VecSeq","..","accessor",
        "aclone","add-classpath","add-watch","agent","agent-error","agent-errors",
        "aget","alength","alias","all-ns","alter","alter-meta!","alter-var-root",
        "amap","ancestors","and","apply","areduce","array-map","aset","aset-boolean",
        "aset-byte","aset-char","aset-double","aset-float","aset-int","aset-long",
        "aset-short","assert","assoc","assoc!","associative?","atom","await",
        "await-forbases","bean","bigdec","bigint","biginteger","binding","bit-and",
        "bit-and-not","bit-clear","bit-flip","bit-not","bit-or","bit-set","bit-shift-left",
        "bit-shift-right","bit-test","bit-xor","boolean","boolean-array","booleans",
        "bound-fn","bound-fn*","bound?","butlast","byte","byte-array","bytes","case",
        "cast","char","char-array","char-escape-string","char-name-string","char?",
        "chars","class","class?","clear-agent-errors","clojure-version","coll?",
        "commute","comp","comparator","compare","compare-and-set!","compile","complement",
        "concat","cond","conj","conj!","cons","constantly","construct-proxy","contains?",
        "count","counted?","create-ns","create-struct","cycle","dec","dec'","decimal?",
        "declare","default-data-readers","definline","definterface","defmacro","defn-",
        "defonce","defstruct","delay","delay?","deliver","denominator","deref",
        "derive","descendants","disj","disj!","dissoc","dissoc!","distinct","distinct?",
        "doall","dorun","dosync","doto","double","double-array","doubles",
        "drop","drop-last","drop-while","empty","empty?","ensure","enumeration-seq",
        "error-handler","error-mode","eval","even?","every-pred","every?","ex-data",
        "ex-info","extend","extend-protocol","extend-type","extenders","extends?",
        "false?","ffirst","file-seq","filter","filterv","find","find-keyword","find-ns",
        "find-var","first","flatten","float","float-array","float?","floats","flush","fn?",
        "fnext","fnil","force","frequencies","future","future-call","future-cancel",
        "future-cancelled?","future-done?","future?","gen-class","gen-interface","gensym",
        "get","get-in","get-method","get-proxy-class","get-thread-bindings","get-validator",
        "group-by","hash","hash-map","hash-set","identical?","identity","if-let","if-not",
        "ifn?","in-ns","inc","inc'","init-proxy","instance?","int","int-array","integer?",
        "interleave","intern","interpose","into","into-array","ints","io!","isa?","iterate",
        "iterator-seq","juxt","keep","keep-indexed","key","keys","keyword","keyword?","last",
        "lazy-cat","lazy-seq","let->","line-seq","list","list*","list?","load","load-file",
        "load-reader","load-string","loaded-libs","locking","long","long-array","longs","loop",
        "macroexpand","macroexpand-1","make-array","make-hierarchy","map","map-indexed","map?",
        "mapcat","mapv","max","max-key","memfn","memoize","merge","merge-with","meta",
        "methods","min","min-key","mod","name","namespace","namespace-munge","neg?",
        "newline","next","nfirst","nil?","nnext","not","not-any?","not-empty","not-every?",
        "not=","ns-aliases","ns-imports","ns-interns","ns-map","ns-name","ns-publics",
        "ns-refers","ns-resolve","ns-unalias","ns-unmap","nth","nthnext","nthrest","num",
        "number?","numerator","object-array","odd?","or","parents","partial","partition",
        "partition-all","partition-by","pcalls","peek","persistent!","pmap","pop","pop!",
        "pop-thread-bindings","pos?","pr","pr-str","prefer-method","prefers","print",
        "print-str","printf","println","println-str","prn","prn-str","promise","proxy",
        "proxy-mappings","proxy-super","push-thread-bindings","pvalues","quot","rand",
        "rand-int","rand-nth","range","ratio?","rational?","rationalize","re-groups",
        "re-matcher","re-pattern","read","read-line","read-string","realized?","reduce",
        "reduce-kv","reduced","reduced?","reductions","ref","ref-history-count","ref-max-history",
        "ref-min-history","ref-set","refer","refer-clojure","reify","release-pending-sends",
        "rem","remove","remove-all-methods","remove-method","remove-ns","remove-watch","repeat",
        "repeatedly","replace","replicate","reset!","reset-meta!","resolve","rest","restart-agent",
        "resultset-seq","reverse","reversible?","rseq","rsubseq","satisfies?","second",
        "select-keys","send","send-off","send-via","seq","seq?","seque","sequence",
        "sequential?","set","set-agent-send-executor!","set-agent-send-off-executor!",
        "set-error-handler!","set-error-mode!","set-validator!","set?","short","short-array",
        "shorts","shuffle","shutdown-agents","slurp","some","some-fn","sort","sort-by",
        "sorted-map","sorted-map-by","sorted-set","sorted-set-by","sorted?","special-symbol?",
        "spit","split-at","split-with","str","string?","struct","struct-map","subs","subseq",
        "subvec","supers","swap!","symbol","symbol?","sync","take","take-last",
        "take-nth","take-while","test","test->","test->>","the-ns","thread-bound?",
        "time","to-array","to-array-2d","trampoline","transient","tree-seq","true?",
        "type","unchecked-add","unchecked-add-int","unchecked-byte","unchecked-char",
        "unchecked-dec","unchecked-dec-int","unchecked-divide-int","unchecked-double",
        "unchecked-float","unchecked-inc","unchecked-inc-int","unchecked-int","unchecked-long",
        "unchecked-multiply","unchecked-multiply-int","unchecked-negate","unchecked-negate-int",
        "unchecked-remainder-int","unchecked-short","unchecked-subtract",
        "unchecked-subtract-int","underive","update-proxy","val","vals",
        "var-get","var-set","var?","vary-meta","vec","vector","vector-of","vector?",
        "when","when->","when->>","when-first","when-let","when-not","while","with-bindings",
        "with-bindings*","with-in-str","with-local-vars","with-meta","with-open","with-out-str",
        "with-precision","with-redefs","with-redefs-fn","xml-seq","zero?","zipmap",
        "clojure.core.protocols","CollReduce","coll-reduce","IKVReduce","kv-reduce",
        "InternalReduce","internal-reduce","Cat","->Cat","append!","cat","drop","filter",
        "flatten","fold","foldcat","folder","map","mapcat","monoid","reduce","reducer",
        "remove","take","take-while",
       
     // snippets
        {"trigger":":require","contents":"(:require [${1:namespace}${2: :as [${3:name}]})","description":"require"},
        {"trigger":"assoc-in","contents":"(assoc-in ${1:assoc-struct} [${2:keys}] ${3:value})","description":"Assoc-In"},
        {"trigger":"comment","contents":"(comment\n  $0\n  )","description":"comment"},
        {"trigger":"condp","contents":"(condp ${1:pred} ${2:expr}\n  $0)","description":"condp"},
        {"trigger":"defmethod","contents":"(defmethod ${1:name} ${2:match}\n  [${3:args}]\n  $0)","description":"defmethod"},
        {"trigger":"defmulti","contents":"(defmulti ${1:name} ${2:dispatch-fn})","description":"defmulti"},
        {"trigger":"defn","contents":"(defn ${1:name} ${2:\n  \"${3:doc-string}\"\n  }[${4:arg-list}]\n  $0)","description":"defn"},
        {"trigger":"defprotocol","contents":"(defprotocol ${1:Name}\n  $0)","description":"defprotocol"},
        {"trigger":"defrecord","contents":"(defrecord ${1:Name} [${2:fields}]\n  ${3:Protocol}\n  $0)","description":"defrecord"},
        {"trigger":"deftest","contents":"(deftest test-${1:name}\n  $0)","description":"deftest"},
        {"trigger":"doseq","contents":"(doseq [${1:value} ${2:range}${3:\n      :let [${5:symbol} ${6:expr}]}${7:\n      :when ${8:conditional}}]\n  ${9:exprs})","description":"doseq"},
        {"trigger":"deftype","contents":"(deftype ${1:Name} [${2:fields}]\n  ${3:Protocol}\n  $0)","description":"deftype"},
        {"trigger":"fn","contents":"(fn [${1:arg-list}] $0)","description":"fn"},
        {"trigger":"for","contents":"(for [${1:value} ${2:range}${3:\n      :let [${4:symbol} ${5:expr}]}${6:\n      :when ${7:conditional}}]\n  ${8:expr})","description":"for"},
        {"trigger":"format","contents":"(format \"${1:format}\" ${2:strings})","description":"format"},
        {"trigger":"fr","contents":"(fresh [${1:vars}]\n  $0)","description":"fresh"},
        {"trigger":"if","contents":"(if ${1:test-expr}\n  ${2:then-expr}\n  ${3:else-expr})","description":"if"},
        {"trigger":"import","contents":"(:import [${1:package}])","description":"import"},
        {"trigger":"kwargs","contents":"{:keys [${1:keys}]${2: :or {${3:defaults}}}}","description":"Keyword args"},
        {"trigger":"let","contents":"(let [$1]\n  $0)","description":"let"},
        {"trigger":"letfn","contents":"(letfn [(${1:name) [${2:args}]\n          $0)])","description":"letfn"},
        {"trigger":"m","contents":"(${1:name} [${2:this} ${3:args}]\n  $0)","description":"method"},
        {"trigger":"ns","contents":"(ns ${1:name}\n  $0)","description":"ns"},
        {"trigger":"dotime","contents":"(dotimes [_ 10]\n  (time\n    (dotimes [_ ${1:times}]\n      $0)))","description":"Performance"},
        {"trigger":"pm","contents":"(${1:name} [${2:this} ${3:args}])","description":"protocol method"},
        {"trigger":"r*","contents":"(run* [q]\n  $0)","description":"run*"},
        {"trigger":"re-find","contents":"(re-find #\"${1:regex}\" ${2:string})","description":"Regex Find"},
        {"trigger":"re-matches","contents":"(re-matches #\"${1:regex}\" ${2:string})","description":"Regex Math"},
        {"trigger":"re-seq","contents":"(re-seq #\"${1:regex}\" ${2:string})","description":"Regex Seq"},
        {"trigger":"refer","contents":"(:refer-clojure :exclude [$0])","description":"refer"},
        {"trigger":"run","contents":"(run ${1:n} [q]\n  $0)","description":"run-n"},
        {"trigger":"str-replace","contents":"[(${1:clojure.string}/replace ${2:string} #\"${3:regex}\" ${4:replacement})","description":"String Replace"},
        {"trigger":"update-in","contents":"(update-in ${1:assoc-struct} [${2:keys}]\n  ${3:fn args})","description":"update-in"},
        {"trigger":"use","contents":"(:use [${1:namespace}${2: :only [${3:fns}]}])","description":"use"},
        
    // Errors and Exceptions
    //None
        
    // 'Magic' Methods
    //None

        // Standard Library
        "clojure.core",
        "clojure.data",
        "clojure.edn",
        "clojure.inspector",
        "clojure.instant",
        "clojure.java.browse",
        "clojure.java.io",
        "clojure.java.javadoc",
        "clojure.java.shell",
        "clojure.main",
        "clojure.pprint",
        "clojure.reflect",
        "clojure.repl",
        "clojure.set",
        "clojure.stacktrace",
        "clojure.string",
        "clojure.template",
        "clojure.test",
        "clojure.walk",
        "clojure.xml",
        "clojure.zip"

    ]
}
